Defining Software

Today, most professionals and many members of the public at large feel that they
understand software. But do they?
A textbook description of software might take the following form: 
Software is: (1) instructions (computer programs) that when executed provide desired
features, function, and performance; (2) data structures that enable the programs to ad-
equately manipulate information, and (3) descriptive information in both hard copy and
virtual forms that describes the operation and use of the programs.
There is no question that other more complete definitions could be offered.
But a more formal definition probably won’t measurably improve your under-
standing. To accomplish that, it’s important to examine the characteristics of soft-
ware that make it different from other things that human beings build. Software is a
logical rather than a physical system element. Therefore, software has characteris-
tics that are considerably different than those of hardware:
1.
Software is developed or engineered; it is not manufactured in the classical sense.
Although some similarities exist between software development and hard-
ware manufacturing, the two activities are fundamentally different. In both
activities, high quality is achieved through good design, but the manufactur-
ing phase for hardware can introduce quality problems that are nonexistent
How should
we define
software?
?
Software is
engineered, not
manufactured.
pre75977_ch01.qxd  11/27/08  3:11 PM  Page 4
(or easily corrected) for software. Both activities are dependent on people,
but the relationship between people applied and work accomplished is
entirely different (see Chapter 24). Both activities require the construction of
a “product,” but the approaches are different. Software costs are concen-
trated in engineering. This means that software projects cannot be managed
as if they were manufacturing projects.
2.
Software doesn’t “wear out.”
Figure 1.1 depicts failure rate as a function of time for hardware. The rela-
tionship, often called the “bathtub curve,” indicates that hardware exhibits
relatively high failure rates early in its life (these failures are often attributa-
ble to design or manufacturing defects); defects are corrected and the failure
rate drops to a steady-state level (hopefully, quite low) for some period of
time. As time passes, however, the failure rate rises again as hardware com-
ponents suffer from the cumulative effects of dust, vibration, abuse, tempera-
ture extremes, and many other environmental maladies. Stated simply, the
hardware begins to wear out.
Software is not susceptible to the environmental maladies that cause
hardware to wear out. In theory, therefore, the failure rate curve for software
should take the form of the “idealized curve” shown in Figure 1.2. Undiscov-
ered defects will cause high failure rates early in the life of a program.
However, these are corrected and the curve flattens as shown. The idealized
curve is a gross oversimplification of actual failure models for software.
However, the implication is clear—software doesn’t wear out. But it does
deteriorate!
CHAPTER 1
SOFTWARE AND SOFTWARE ENGINEERING
5
“Wear out”
“Infant
mortality”
Time
Failure rate
FIGURE 1.1
Failure curve
for hardware
Software doesn’t wear
out, but it does
deteriorate.
If you want to reduce
software deterioration,
you’ll have to do
better software design
(Chapters 8 to 13).
pre75977_ch01.qxd  11/27/08  3:11 PM  Page 5
This seeming contradiction can best be explained by considering the
actual curve in Figure 1.2. During its life,2 software will undergo change. As
changes are made, it is likely that errors will be introduced, causing the
failure rate curve to spike as shown in the “actual curve” (Figure 1.2). Before
the curve can return to the original steady-state failure rate, another change
is requested, causing the curve to spike again. Slowly, the minimum failure
rate level begins to rise—the software is deteriorating due to change.
Another aspect of wear illustrates the difference between hardware and
software. When a hardware component wears out, it is replaced by a spare
part. There are no software spare parts. Every software failure indicates an
error in design or in the process through which design was translated into
machine executable code. Therefore, the software maintenance tasks that
accommodate requests for change involve considerably more complexity
than hardware maintenance.
3.
Although the industry is moving toward component-based construction, most
software continues to be custom built.
As an engineering discipline evolves, a collection of standard design compo-
nents is created. Standard screws and off-the-shelf integrated circuits are
only two of thousands of standard components that are used by mechanical
and electrical engineers as they design new systems. The reusable compo-
nents have been created so that the engineer can concentrate on the truly
innovative elements of a design, that is, the parts of the design that represent
6
CHAPTER 1
SOFTWARE AND SOFTWARE ENGINEERING
Increased failure
rate due to side
effects
Time
Failure rate
Change
Actual curve
Idealized curve
FIGURE 1.2
Failure curves
for software
2
In fact, from the moment that development begins and long before the first version is delivered,
changes may be requested by a variety of different stakeholders.
Software engineering
methods strive to
reduce the magnitude
of the spikes and the
slope of the actual
curve in Figure 1.2.
uote:
“Ideas are the
building blocks of
ideas.”
Jason Zebehazy
pre75977_ch01.qxd  11/27/08  3:11 PM  Page 6
something new. In the hardware world, component reuse is a natural part of
the engineering process. In the software world, it is something that has only
begun to be achieved on a broad scale.
A software component should be designed and implemented so that it can
be reused in many different programs. Modern reusable components encap-
sulate both data and the processing that is applied to the data, enabling the
software engineer to create new applications from reusable parts.3 For exam-
ple, today’s interactive user interfaces are built with reusable components
that enable the creation of graphics windows, pull-down menus, and a wide
variety of interaction mechanisms. The data structures and processing detail
required to build the interface are contained within a library of reusable
components for interface construction.
1.1.2
